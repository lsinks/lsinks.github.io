---
title: "Leaflet_tester"
date: 06-30-2023
categories: [Data-Viz, openxlsx, stringr, fuzzyjoin, mapview, sf] # self-defined categories
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

This is a draft of a project for my father. I want to make sure the photo files structure renders properly online. This will be revised and reposted later as a tutorial. It will also be deleted once I get his input.

```{r}
library(tidyverse) # who doesn't want to be tidy?
library(ggthemes) # more themes for ggplot
library(gt) # For nice tables
library(ggrepel) # to help position labels in ggplot graphs
library(openxlsx) # importing excel files from a URL
library(fuzzyjoin) # for joining on inexact matches
library(sf) # for handling geo data
library(mapview) # quick interactive mapping
library(leaflet) # more mapping
library(here)
library(magick)
library(skimr)

```

Reading in his spreadsheet

```{r}
blog_folder <- "posts/2023-06-30-leaflet2"
photo_folder <- "Photos"
archive_folder <- "Archive"
problem_folder <- "Problem"
#data_file <- "Tombstone_Data_small.xlsx"
data_file <- "Tombstone Data.xlsx"
# read in excel sheet
tombstones <-
  read.xlsx(here(blog_folder, data_file),
    sheet = 1
  )

```

Overview

# Fixing GPS

Latitude and longitude data contains some stray degree and minute symbols. The degree symbol appears both as a straight and curved apostrophe and the degree symbols appear both as o and O. This cleaning needs to be done on both N and W columns.

```{r}

tombstones <- tombstones %>%
mutate(N = str_replace_all(N, pattern = "’", " ")) %>%
mutate(N = str_replace_all(N, pattern = "O", " "))  %>%
mutate(N = str_replace_all(N, pattern = "o", " "))  %>%
mutate(N = str_replace_all(N, pattern = "'", " "))  %>% 
mutate(W = str_replace_all(W, pattern = "’", " ")) %>%
mutate(W = str_replace_all(W, pattern = "O", " "))  %>% 
mutate(W = str_replace_all(W, pattern = "o", " ")) %>%
mutate(W = str_replace_all(W, pattern = "'", " ")) 



```

Next, I'm converting the N and W data to decimal latitude and longitude. S/W should be "-" and N/E should be "+". I split the degree/minute/second data into parts and then do the conversion. I delete the intermediate components when done.

```{r}
#converting to decimal latitude
tombstones <- tombstones %>%
  mutate(part1N = str_split_fixed(N, pattern = " ", n = 2) ) %>%
  mutate(N_degree = as.numeric(part1N[,1])) %>%
  mutate(part2N = str_split_fixed(part1N[,2], pattern = '\\.', n = 2)) %>%
  mutate(N_minute = as.numeric(part2N[,1])) %>%
  mutate(N_second = as.numeric(part2N[,2])) %>%
  mutate(lat = N_degree + N_minute/60 + N_second/3600)

#converting to decimal longitude  
tombstones <- tombstones %>%
  mutate(part1W = str_split_fixed(W, pattern = " ", n = 2) ) %>%
  mutate(W_degree = as.numeric(part1W[,1])) %>%
  mutate(part2W = str_split_fixed(part1W[,2], pattern = '\\.', n = 2)) %>%
  mutate(W_minute = as.numeric(part2W[,1])) %>%
  mutate(W_second = as.numeric(part2W[,2])) %>%
  mutate(long = -(W_degree + W_minute/60 + W_second/3600)) 

tombstones <- tombstones %>%
  select(-contains("part"))


```

# Cleaning Up Cemetery data

Let's look at the cemetery data. spaces

```{r}
tombstones <- tombstones %>%
#mutate(Middle.Name = ifelse(is.na(Middle.Name), "", Middle.Name)) %>%
  mutate(Cemetery = ifelse(is.na(Cemetery), "", Cemetery))


```

```{r}
cems <- tombstones %>% group_by(Cemetery) %>% count(sort = TRUE)
```

Let's look at how many unique cemetery names there are. This will help with typos.

```{r}
cems_unique <- tombstones %>% distinct(Cemetery)
```

Actually just look at the sorted tombstone list. This would be easier to do in excel, but there are weird formatting things that make it difficult to sort.

```{r}
temp <- tombstones %>% arrange(Cemetery)
```

# Cleaning Up Names

My father's photo naming convention is "last name first name middle initial". I'm going to construct a variable full_name from the spreadsheet data and use that to match.

The middle name column is problematic. Sometimes it is the middle name. Sometimes it is a notes like "shared family tombstone". Sometimes it is the middle initial from the gravestone, but with the full name filled in with brackets like A\[lvis\]. Sometimes it is a maiden name or the name of the spouse.

Easy stuff first- stripping out extra spaces and periods and the abreviation ux (latin for wife) and us (a typo for ux). REMEMBER TO ESCAPE PERIODS and brackets

```{r}
tombstones2 <- tombstones %>%
  mutate(Middle.Name = str_replace(Middle.Name, "ux ", "")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "us ", "")) %>%
  mutate(Extra_Middle_Name = str_extract(Middle.Name, "\\[.+\\]")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "\\[.+\\]", "")) %>%
  mutate(Middle.Name = str_replace(Middle.Name, "\\.", "")) %>%
  mutate(Middle.Name = str_trim(Middle.Name, side = c("both"))) %>%
  mutate(Middle.Name = na_if(Middle.Name, ""))
  
```

This fixes most of the issues, but not all. I'm going to see how the rest of this going and then come back and fix problem cases. It is possible that the entire middle name should be thrown out if ux is there, but I did see that some photos seem to have spouse names.

```{r}
tombstones2 <- tombstones2 %>%
  mutate(full_name_MI = ifelse(
    is.na(Middle.Name) == TRUE,
    Middle.Name,
    paste(Surname, First.Name, Middle.Name, sep = " ")
  )) %>%
  mutate(full_name = paste(Surname, First.Name, sep = " "))
```

Now, I'm going to split this into two dataframe.

PEOPLE WHO HAD MIDDLE NAMES removed are not nas!!!!! FIXED ABOVE

```{r}

tombstones_middle <- tombstones2 %>%
  filter(is.na(Middle.Name) == FALSE)
tombstones_n_omiddle <- tombstones2 %>%
  filter(is.na(Middle.Name) == TRUE)

```

# Matching to Photos

Now, I'm generating a list of all the photo names and converting it to a dataframe. I'm going to match against this list. The folder he gave me contains non-photos too, but I think they will be filtered out by the join.

```{r}
photo_names = list.files(here(blog_folder, photo_folder))
photo_df = as.data.frame(photo_names)
```

I'm going to remove all duplicate names for now.

```{r}
multiples <- tombstones_middle %>% group_by(full_name) %>% count(sort = TRUE) %>% filter(n > 1)
```

Use an antijoin to filter out everything that doesn't match.

```{r}
tombstones_unique_names <- tombstones_middle %>%
  anti_join(multiples)
```

Okay, this seems to be fully unique names.

The photo name format contains the fullname, but then might include additional description, such as:

```{r}
photo_df$photo_names[12]
```

So I'm going to have to a fuzzy/ partial match. So using "Appleton Richard" will correctly match with that photo. The problem is that the fuzzy match might also incorrect match people with similar names.

So, I need to match to the most complete name first, and then the least complete name.

```{r}
tombstones_merged <- fuzzy_right_join(photo_df, tombstones_unique_names, 
                             by = c("photo_names" = "full_name_MI"),
                             match_fun = str_detect)

```

Seeing what photos weren't matched. I'm actually going to move them somewhere else for the second round of matching

#At a quick glance, this looks to be correct.

```{r}
not_matched_first_round <- anti_join(photo_df, tombstones_merged)

index <- 1
for (index in seq(1:nrow(not_matched_first_round))) {
  file.rename(from = here(blog_folder, photo_folder, not_matched_first_round$photo_names[index]),
                         to = here(blog_folder, problem_folder, not_matched_first_round$photo_names[index] ))
}


```

I'm dropping all the NAs in the photo_names column.

```{r}

#deleting NAs
tombstones_merged <- tombstones_merged %>%
  drop_na(photo_names)

```

How many people have multiple photos?

```{r}
multiples <- tombstones_merged %>% group_by(full_name) %>% count(sort = TRUE) %>% filter(n > 1)
```

Look at these high multiples more closely.

```{r}

df_temp <- tombstones_merged %>%
  filter(full_name == multiples$full_name[1]) 
df_temp

```

https://stackoverflow.com/questions/61196196/image-append-on-dynamic-number-of-variables

```{r}

#testing
if (nrow(multiples) > 0 ) {
index <- 1

for (index in seq(1:nrow(multiples))) {
  df_temp <- tombstones_merged %>%
    filter(full_name == multiples$full_name[index])
  df_temp
  these <-
    as.list(here(blog_folder, photo_folder, df_temp$photo_names))
  photo_panel <-
    image_append(do.call("c", lapply(these, image_read)))
  image_write(
    photo_panel,
    path =  here(
      blog_folder,
      photo_folder,
      paste0(df_temp$full_name[1], "_panel.png")
    ),
    format = "png"
  )
  index2 <- 1
  for (index2 in seq(1:nrow(df_temp))) {
    file.rename(
      from = here(blog_folder, photo_folder, df_temp$photo_names[index2]),
      to = here(blog_folder, archive_folder, df_temp$photo_names[index2])
    )
  }
}
}
```

Now I need to redo everything so it will only match on the panel figures and not the ones I moved.

```{r}
photo_names2 = list.files(here(blog_folder, photo_folder))
photo_df_MI_final = as.data.frame(photo_names2)
tombstones_middle <- fuzzy_right_join(photo_df_MI_final, tombstones_middle, 
                             by = c("photo_names2" = "full_name_MI"),
                             match_fun = str_detect)
```

Dropping any NAs in lat/long. Converting it to a SF geo object. I'm adding some jitter to the coordinates; tombstones that are very close to each other have the same coordinates and show up as overlapping on the map.

```{r}
tombstones_final <- tombstones_final %>% drop_na(lat) %>% drop_na(long)


tombstones_geo <- st_as_sf(tombstones_merged, coords = c("long", "lat"), crs = 4326)
tombstones_geo <- st_jitter(tombstones_geo, factor = 0.001)


```

Final map.

```{r}
#| column: page
#| 
image_list <- tombstones_geo$photo_names

labels <- sprintf(
  "<strong>tombstones_geo$full_name</strong> <br/>,
  tombstones_geo$Cemetery" ) %>% lapply(htmltools::HTML)

leaflet() %>%
  addTiles() %>%
  #addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    data = tombstones_geo,
    label = ~ (paste( First.Name, Surname, "-", Cemetery, "Cemetery", sep = " ")), 
   # label = ~labels,
   # popup = leafpop::popupImage(paste0(here(blog_folder, photo_folder),"/", image_list)),
    clusterOptions = markerClusterOptions(),
    opacity = 1,
    radius = 10,
    color = "blue",
    stroke = NA,
    group = "group1"
  )  %>%

# popup = ~tag,


   leafpop::addPopupImages(
    image = paste0(here(blog_folder, photo_folder),"/", image_list),
     src = local,
     group = "group1", width = 600,
    maxHeight = 300, maxWidth = 600
   )

```
