---
title: "Credit Card Fraud: A Tidymodels Tutorial"
description: "An Imbalanced Class Problem"
twitter-card:
  image: "thumbnail.png"
date: 04-11-2023
date-modified: last-modified
categories: [R, R-code, tidymodels, machine learning, classifiers] # self-defined categories
citation:
  url: https://lsinks.github.io/posts/2023-04-11-credit-card-fraud/fraud_tutorial.html
image: "thumbnail.png"
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
---

# 

I've used the credit card fraud dataset from Datacamp for a variety of projects, most notabily the tidymodels and imbalance class tutorials. I've used it when I was learning Tableau and also Python. One advantage of working with the same dataset is that it becomes easier to catch errors in your analysis, or even in the dataset itself.

The geographic data always seemed a bit odd. The data dictionary, from datacamp, defines 3 sets of geographic variables. That will produce a notebook like [this](https://app.datacamp.com/workspace/w/f3a94059-683b-4bc6-b354-9b98cf3d5242/edit) with the dataset and the data dictionary.

|            |                                |
|------------|--------------------------------|
| city       | City of Credit Card Holder     |
| state      | State of Credit Card Holder    |
| lat        | Latitude Location of Purchase  |
| long       | Longitude Location of Purchase |
| merch_lat  | Latitude Location of Merchant  |
| merch_long | Longitude Location of Merchant |

The original source of the data (prior to preparation by DataCamp) can be found [here](https://www.kaggle.com/kartik2112/fraud-detection?select=fraudTrain.csv) and does not include a data dictionary.

lat and merch_lat and long and merch_long were highly, but not perfectly, correlated, so I orginally dropped the merchant coordinates.

While playing with the dataset in Tableau, I became very confused about what lat/long and merch_lat/merch_long actually represented.

I puzzled over this for a long time (I finalized my Tableau dashboards in July, but never did anything with them, because I was so confused by my results. I did check the Tableau results by manually pulling out some subsets of data in R, and what I was seeing in my pretty Tableau maps was correct.

While trying to write up some thoughts about Tableau (in November), I decided to delve back into this question. I had looked at the Kaggle notebook discussions when I first starting working on this (which was probably last year!) and didn't find much info. Now, someone had posted a comment about the two coordinates and someone replied that the lat/long is the location of the card holder's home address, not the purchase location. This is so obvious (and clearly explains the results I showed in my dashboard) that it is kind of funny that I didn't figure this out. It is a good lesson in checking all your assumptions carefully when things don't make sense. I assumed that a dataset prepared by Datacamp would be correct and I assumed any weird results were because the person who coded the simulation had made some weird choices.

So, now I'm going to reanalyze the geographic data with this new definiton in mind.

# 1. Set-up steps

Loading the necessary libraries.

```{r}
#| label: loading-libraries
#| warning: false


# loading tidyverse
library(tidyverse) #core tidyverse

# visualization
library(viridis) #color scheme that is colorblind friendly
library(ggthemes) # themes for ggplot
library(gt) # to make nice tables
library(cowplot) # to make multi-panel figures
library(corrplot) # nice correlation plot

#Data Cleaning
library(skimr) #provides overview of data and missingness

#Geospatial Data
library(tidygeocoder) #converts city/state to lat/long

```

I'm setting a global theme for my figures. I'm using [cowplot](https://wilkelab.org/cowplot/index.html) to create some composite figures, and apparently you must choose a cowplot theme if you set a global theme. You can use a ggtheme on a graph by graph basis, but not globally.

```{r}
#| label: fig-options
#  setting global figure options

theme_set(theme_cowplot(12))
```

Loading the data. This is a local copy that is part of the workspace download from Datacamp.

```{r}
#| label: import-data
#  Reading in the data
fraud <- read_csv('C:/Users/drsin/OneDrive/Documents/R Projects/lsinks.github.io/posts/2023-04-11-credit-card-fraud/datacamp_workspace/credit_card_fraud.csv', show_col_types = FALSE) 
fraud
```

## The lat/long match the city state

If the lat/long really encode the home address of the card user, then the city, state (of the card user's address) should be equivalent to the lat/long data. I can convert back and forth using a package like tidygeocoder. I did do this before, and then I calculated the distance between the home city/state and lat/long, which I thought was transaction location. I got some very large distances, which doesn't make sense if lat/long is of the home location. I don't expect to get 0, due to some imprecision in the geocoding, but I do expect a small number (that probably varies with the size of the city.) Requesting the lat/long of San Diego, CA will return the coordinates of the center of the city, while the lat/long from our dataset will reflect a specific address in San Diego.

I'm going to use the suffix \_calc for calculated values.

I suspect my original geocoding had some errors, so I'm going to check that out first.

Here is my original analysis:

```{r}
# need to pass an address to geo to convert to lat/long
fraud <- fraud %>%
  mutate(address = str_c(city, state, sep = " , "))

# generate a list of distinct addresses to look up
# the dataset is large, so it is better to only look up unique address rather that the address
# for every record
address_list <- fraud %>%
  distinct(address)
```

```{r}
# Reimport the data and load it
home_coords <-
  read_csv('C:/Users/drsin/OneDrive/Documents/R Projects/lsinks.github.io/posts/2023-04-11-credit-card-fraud/datacamp_workspace/downloaded_coords.csv', show_col_types = FALSE)
```

Now join it to fraud. I'm going to store this in fraud2, because I suspect I'm going to discard this data and re-geocode.

```{r}


# imported home coords has an extra set of quotation marks
home_coords <- home_coords %>%
  mutate(address = str_replace_all(address, "\"", "")) %>%
  rename(lat_calc = lat, long_calc = long)

# use a left join on fraud and home_coords to assign the coord to every address in fraud
fraud <- fraud %>%
  left_join(home_coords, by = "address")
```

Now calculate the distance between these coordinates and lat/long. They should be encoding the same information, so the distance should be small.

```{r}
# Code Block 14: Distance Between Home and Transaction

# I believe this assuming a spherical Earth

# convert to radians
fraud <- fraud %>%
  mutate(
    lat1_radians = lat_calc / 57.29577951,
    lat2_radians = lat / 57.29577951,
    long1_radians = long_calc / 57.29577951,
    long2_radians = long / 57.29577951
  )

# calculating distance
fraud <-
  fraud %>% mutate(distance_miles = 3963.0 * acos((sin(lat1_radians) * sin(lat2_radians)) + cos(lat1_radians) * cos(lat2_radians) * cos(long2_radians - long1_radians)
  ))

# calculating the correlation
fraud_distance <- round(cor(fraud$distance_miles, fraud$is_fraud), 3) 
```

Now the original graph

```{r}
#| label: distance-and-fraud
# Code Block 15: Distance from Home and Fraud
ggplot(fraud, aes(distance_miles, is_fraud , fill = factor(is_fraud))) +
  geom_point(
    alpha = 1,
    shape = 21,
    colour = "black",
    size = 5,
    position = "jitter"
  ) +
  scale_fill_viridis(
    discrete = TRUE,
    labels = c('Not Fraud', 'Fraud'),
    name = ""
  ) +
  ggtitle("Figure 5: How far from home does fraud occur?") +
  xlab("Distance from Home (miles)") +
  ylab("Is Fraud?")
```

So what is going on? Either the original geocoding is wrong or lat/long is not the home address.

I can take the generated lat/longs and reverse geocode them to determine city/state.

```{r}
#reverse geo_code home block here
```

I included the full output in this, which I didn't do before. The additional information will help with troubleshooting.

```{r}
reverse <- read_csv("home_coords1.csv")
```

Look at this

```{r}
reverse %>% gt()
```

From the very first entry, I can see that Orient, Washington was given coordinates that correspond to Orient, Iowa. It is also clear that city name might be in the city, village, town or hamlet category.

For a quick check of how impactful the incorrect geocoding is, we can look at how many entries have the wrong state.

```{r}
reverse <- reverse %>% select(address, lat_home, long_home, city, hamlet, village, town, state )
```

look at this geo subset

```{r}
reverse %>% gt()
```

```{r}

fraud <- fraud %>% left_join(reverse, by = "address")
```

Select only geo stuff

Convert states to abbreviations

```{r}
fraud$state.y <- state.abb[match(fraud$state.y, state.name)]
```

Was the right state determined from the geocoding?

```{r}

fraud <- fraud %>%
  mutate(right_state = (state.x == state.y))
```

Now remake the Figure 5.

```{r}
ggplot(fraud, aes(distance_miles, is_fraud , fill = right_state)) +
  geom_point(
    alpha = 1,
    shape = 21,
    colour = "black",
    size = 5,
    position = "jitter"
  ) +
  scale_fill_viridis(
    discrete = TRUE,
    labels = c('Wrong State', 'Right State'),
    name = ""
  ) +
  ggtitle("Figure 5: How far from home does fraud occur?") +
  xlab("Distance from Home (miles)") +
  ylab("Is Fraud?")
```

Let's look at the transactions that had a distance greater than 250 miles. They are in the correct state, but I think they must also be incorrectly geocoded.

```{r}
fraud %>% filter((distance_miles > 50) & (right_state == TRUE)) %>% select (city.x, state.x, city.y, hamlet, town, village, state.y) %>% distinct(city.x, state.x,  city.y, hamlet, town, village, state.y) %>% gt()
```

Okay, some definitely are. Vinton/ Winton. Not sure what the deal was with Kaktovik Alaska. It is a small town with 300 people or something. The census bureau says the town has an area of 1 sq. mile.

```{r}
reverse <- read_csv("home_coords1.csv")

```

```{r}
temp2 <- reverse %>% filter(village == "Kaktovik")
```

I suspect the card holder is actually in the North Slope borough, and not in the village. North Slope encompasses almost 95k sq. miles.

```{r}
Ak <- fraud %>% filter( city.x == "Kaktovik" ) %>% select(address, lat, long)
```

take just one

```{r}
Ak <- Ak[1,]
```

Reverse geo_code

```{r}
ak_geo <- Ak %>%
  reverse_geocode(
    lat = lat,
    long = long,
    address = addr,
    limit = 1,
    method = "osm",
    full_results = TRUE
  )
```
